---
title: "系统架构设计师最后冲刺"
date: 2023-11-03T17:21:12+08:00
draft: true
---

## 选择

### 数据库

### **架构风格**

- 软件架构为软件系统提供了一个**结构、行为和属性**的高级抽象
- 软件架构风格是特定应用领域的**惯用模式**，架构定义一个**词汇表**和一组**约束**
- 数据流：面向数据流，按照一定的顺序从前向后执行程序
  - 批处理：以**整体**为单位
  - 管道-过滤器：优点是模块复用、模块独立、可维护性和可扩展行较强、具有并发性；缺点是**不适用于交互性较强的应用**
- 调用/返回：构件之间存在互相调用的关系，一般是显式调用
  - 主程序/子程序
  - 面向对象：优点是模块化、封装、代码共享性好、易维护、可扩充性好；缺点是增加了对象之间的依赖关系
  - 层次结构：支持系统设计过程中的逐级抽象、可扩展性好、支持软件复用；缺点是不同层次之间耦合度高的系统很难实现
- 独立构件：构件之间是相互独立的，不存在显式调用，而是通过事件触发，异步执行
  - 进程通信
  - 事件驱动（隐式调用）：容易实现**并发处理和多任务**、可扩展性好、具有类层次结构、简化代码；缺点是因为是树形结构所以削弱了对系统计算的控制能力、各个**对象间的关系复杂**
- 虚拟机：自定义了一套规则供提供者使用，使用者基于规则来**灵活**开发构件
  - 解释器
  - 规则系统：适用场景为 DSS、人工智能、专家系统
- 仓库：以数据为中心，所有的操作都是围绕数据中心进行的
  - 数据库
  - 超文本
  - 黑板：适用场景为语音识别、知识推理
- 闭环控制：软件与硬件之间可以粗略的表示为一个反馈循环。适用场景为定速巡航、空调温度调节
- C2：通过连接件绑定在一起的按照一组规则运作的并行构件网络

### **质量属性**

- 性能
  - 指系统的响应能力，即要经过多长时间能对某个事件作出响应，或者在某段时间内系统所能处理的事件个数。如**响应时间、吞吐量**
  - **优先级队列、增加计算资源、减少计算开销、引入并发机制、采用资源调度**等
- 可用性
  - 是系统能够正常运行的时间比例，经常用**故障间隔时间**表示
  - **心跳、Ping/Echo、冗余、选举**
- 可靠性
  - 指软件系统在应用或系统错误面前，在意外或错误使用的情况下维持软件系统功能特性的基本能力。如 MTTF、MTBF、MTTR
  - 心跳、Ping/Echo、冗余、选举
  - 与可用性同时出现时选可用性
- 安全性
  - 是指系统在向合法用户提供服务的同时能够阻止非授权用户使用的企图或拒绝服务的能力。如保密性、完整性、不可抵赖性、可控性
  - **入侵检测、用户认证、用户授权、追踪审计**
- 可修改性
  - 指能够快速的以较高的性价比对系统进行变更的能力
  - 接口实现分离、抽象、信息隐藏
- 可变性
  - 指体系结构经扩充或变更而成为新的体系结构的能力
  - 与可修改性同时出现时选可修改性
- 功能性
  - 指系统所能完成所期望的工作的能力
- 互操作性
  - 指作为系统组成部分的软件不是独立存在的，经常与其他系统或自身环境相互作用

### 软件过程模型

- 瀑布模型
  - 从上一项开发活动接受该活动的工作对象作为输入
  - 实施该项活动完成对应的工作内容
  - 工作成果作为输出
  - 对工作成果进行评审，通过进行下一项，否则返回前一项
- 原型模型
  - 第一步就是创建一个快速原型，与客户讨论弄清楚当前系统的需求
  - 对用户的需求是动态响应、逐步纳入的
- 螺旋模型
  - 是一个演化过程模型
  - 将原型模型和瀑布模型结合起来
  - 四个阶段分别为：制定计划、风险分析、实施工程、客户评估
  - **强调了风险分析，适用于庞大复杂的高风险系统**
- V 模型
  - 每个步骤有对应的测试
  - 用于需求明确和需求变更不频繁的情况
- 增量模型
  - 首先开发核心模块功能，然后与用户确认，每次开发一部分功能，并于用户确认
  - 优先级最高的服务最先交付
  - **不利于模块划分**，难点在于如何将客户需求划分为多个增量
  - 与原型模型不同的是增量模型每个增量版本都是独立可操作的作品
- 敏捷模型
  - 核心思想是**适应性、以人为本、迭代增量**
- **统一过程模型 RUP**
  - 9 个核型工作流：业务建模、需求、分析与设计、实现、测试、部署、配置与变更管理、项目管理、环境
  - 特点：用例驱动、以体系结构为中心
  - 四个阶段
    - 初始阶段：定义最终产品视图和业务模型，并**确定系统范围**
    - 细化阶段：**设计及确定系统的体系结构**，制订工作计划及资源要求
    - 构造阶段：**构造产品并继续演进需求**、体系结构、计划直到产品提交
    - 移交阶段：把产品提交给**用户使用**
  - 4+1 视图模型
    - 用例视图，分析人员和测试人员关注
    - 逻辑视图，最终用户关注
    - 实现视图，程序员关注
    - 进程视图，系统集成人员关注
    - 部署视图，系统工程师关注

### 结构化的需求分析

- 结构化的特点：**自顶向下、逐步分解、面向数据**
- 三大模型及数据字典：**功能模型（数据流图）、行为模型（状态转换图）、数据模型（E-R 图）**
  - 数据流图 DFD：数据流、加工、数据存储、外部实体
    - 数据的流向必须经过加工
  - 状态转换图 STD：状态、事件
  - 实体联系图 ER：实体、联系
  - 数据字典：数据元素、数据结构、数据流、数据存储、加工逻辑、外部实体
    - 数据字典就是为数据流中的每个数据流、文件、加工以及组成数据流或文件的数据项作出说明

### 面向对象的需求分析

- 五个活动：认定对象、组织对象、描述对象间的相互作用、确定对象的操作、定义对象的内部信息
- 分析模型
  - 顶层架构图
  - 用例与用例图
  - 领域（分析）概念模型
- 设计模型
  - 软件体系结构图：包图表示
  - 用例实现图：交互图表示
  - 类图
  - 状态图：针对复杂对象
  - 活动图：描述流程化处理过程

### 统一建模语言 UML

- 可视化的建模语言，而非程序设计语言
- 结构包括**构造块（事物、关系、图）、规则和公共机制**
- 关系
  - 关联：没啥特殊的；实线
  - 组合：部分和整体，手和人；实线带菱形实心箭头
  - 聚合：部分和整体，大雁和雁群；实线带另菱形空心箭头
  - 依赖：一个事物的语义依赖于另一个事物的语义的变化而变化；虚线带实心三角箭头
  - 泛化：一般/特殊的关系，子类和父类；实线带空心三角箭头
  - 实现：一个类元指定了另一个类元保证的契约；虚线带空心三角箭头
- 静态图
  - 类图：展现一组对象、接口、协作和它们之间的关系
  - 对象图：展现某一时刻一组对象及它们之间的关系，为类图的快照
  - 用例图：展现一组用例、参与者以及它们之间的关系
  - 构件（组件）图：展现一组构件之间的组织和依赖
  - 部署图：展现物理模块的节点分布，通常一个节点包含一个或多个构件
- 动态图
  - 序列（顺序）图：描述以时间顺序组织的对象之间的交互活动
  - 通信（协作）图：强调参加交互对象的组织
  - 状态图：展现一个状态机，描述单个对象在多个用例中的行为，包括简单的状态和组合状态。转换可以通过事件触发器触发，事件触发后相应的监护条件会进行检查。
  - 活动图：一种特殊的状态图，展现了系统内从一个活动到另一个活动的流程

### 设计模式

- 创建型
  - 抽象工厂(Abstract Factory)：提供一个接口，可以创建一系列相关或互相依赖的对象，而**无需指定它们具体的类**
  - 构建器(Builder)：将一个复杂类的**表示与其构造相分离**，使得相同的构建过程能得出不同的表示
  - 工厂方法(Factory Method)：定义一个创建对象的接口，但**由子类决定需要实例化哪一个类**，使得子类实例化过程推迟
  - 原型(Prototype)：用原型实例指定创建对象的类型，并且**通过拷贝这个原型来创建新的对象**
  - 单例(Singleton)：保证**一个类只有一个实例**，并且提供一个访问它的全局访问点
- 结构型
  - 适配器(Adapter)：将一个类的接口**转换**成用户希望得到的另一种接口，它是原本不**兼容**的接口得以协同工作
  - 桥接(Bridge)：将类的**抽象部分和它的实现部分分离**开来，使得它们可以独立变化
  - 组合(Composite)：将对象组合成**树形结构**以表示“整体-部分”的层次结构，使得用户对单个对象和组合对象的使用具有一致性
  - 装饰(Decorator)：动态的给一个对象**添加一些额外的职责**。提供了用子类扩展功能的一个灵活的替代
  - 外观(Facade)：定义一个**对外统一的高层接口**，为子系统中的一组接口提供一个一致的外观，从而简化了该子系统的使用
  - 享元(Flyweight)：提供支持大量**细粒度对象共享**的有效方法
  - 代理(Proxy)：为其他对象提供一种**代理控制**这个对象的访问
- 行为型
  - 职责链(Chain of Responsibility)：传递请求、职责链接
  - 命令(Command)：日志记录、可撤销
  - 解释器(Interpreter)：解释器、虚拟机
  - 迭代器(Iterator)：顺序访问、不暴露内部
  - 中介者(Mediator)：不直接引用
  - 备忘录(Memento)：保存、恢复
  - 观察者(Observer)：通知、自动更新
  - 状态(State)：状态改变行为
  - 策略(Strategy)：算法替换
  - 模版方法(Template Method)：算法骨架、步骤延迟、子类实现
  - 访问者(Visitor)：数据和操作分离

## 案例

### 考点分析

1. **架构**: 2023 之前案例的第一题是稳定的考架构风格+质量属性送分，教材改版后应该是下篇的八大架构中出题了，所以新版教材中的**八大架构的特点和架构图**是重中之重。
2. **建模（需求分析）**：结构化建模（需求分析）和面向对象的建模（需求分析）轮流来，结构化建模主要考**数据流图+数据字典**，面向对象的建模主要考**用例图、类图、活动图、状态图**。
3. **数据库**：主要是数据库实际应用中面临的问题，基本和数据库面试题差不多，还比较喜欢考 Redis。
4. Web：偏理论的居多，主要是 Java 方向，撞到了枪口上再选。
5. 嵌入式/新技术：尽量不选。

总体来说的选题思路：架构强制选，建模必选，数据库 > WEB，嵌入式/新技术不要选。

### 八大架构

### 建模（需求分析）

#### 结构化建模（需求分析）

- 结构化特点：**自顶向下，逐步分解，面向数据**。
- 三大模型：功能模型（数据流图）、行为模型（状态转换图）、数据模型（E-R 图）以及数据字典。
- 数据字典：数据字典是在 DFD 的基础上，对 DFD 中出现的所有命名元素都加以定义，使得每个图形元素的名字都有一个确切的解释。DFD 和数据字典等工具相配合，就可以从图形和文字两个方面对系统的逻辑模型进行完整的描述。是所有人员工作的依据，统一的标准。它可以确保数据在系统中的完整性和一致性。数据字典中一般有 6 类条目，分别是数据元素、数据结构、数据流、数据存储、加工逻辑和外部实体。不同类型的条目有不同的属性需要描述。

![结构化建模](https://jsd.cdn.zzko.cn/gh/orionpax1997/picx-images-hosting@master/image.13lle6ur3n.webp)

##### **功能模型（数据流图）**

- 作用：分析阶段，建立系统的功能模型，从而完成需求分析。设计阶段，为模块划分与模块之间接口设计提供依据。
- 数据流：由一组固定成分的数据组成，表示数据的流向。在 DFD 中，数据流的流向必须经过加工。
- 加工：描述了输入数据流到输出数据流之间的变换。
  - 有输入但是没有输出，称之为“黑洞”。
  - 有输出但没有输入。称之为“奇迹”。
  - 输入不足以产生输出，我们称之为“灰洞”。
- 数据存储：用来存储数据。
- 外部实体（外部主体）：是指存在于软件系统之外的人员或组织，它指出系统所需数据的发源地（源）和系统所产生的数据的归宿地（宿）。
- 数据流图的平衡原则
  - 父图（上层数据流图）与子图（下层数据流图）平衡：
    - 个数一致：两层数据流图中的数据流个数一致
    - 方向一致：两层数据流图中的数据流方向一致
  - 子图内部的平衡
    - 黑洞：加工只有输入没有输出
    - 奇迹：加工只有输出没有输入
    - 灰洞：加工中输入不足以产生输出

![数据流图](https://jsd.cdn.zzko.cn/gh/orionpax1997/picx-images-hosting@master/image.4uaqzemrck.webp "数据流图")
![分层数据流图](https://jsd.cdn.zzko.cn/gh/orionpax1997/picx-images-hosting@master/image.pf5narre5.webp "分层数据流图")

##### 数据模型（E-R 图）

- 作用
  - 数据建模与抽象：E-R 图帮助数据库设计师从现实世界中抽象出数据实体和它们之间的关系，将复杂的现实情况转化为易于理解和表达的图形化结构。通过 E-R 图，设计师可以更好地捕捉数据模型的本质，从而准确地定义数据结构。
  - 数据可视化：E-R 图可视化了数据实体、属性和关系之间的联系，使得数据库设计更加直观和易于沟通。设计师和利益相关者可以通过 E-R 图更容易地理解数据库的结构和组织，从而减少沟通误差。
  - 数据规范化：E-R 图可以帮助设计师进行数据规范化，将数据库设计转化为满足数据库范式要求的合理结构。数据规范化是数据库设计的重要原则，有助于减少数据冗余和提高数据的一致性。
  - 数据库系统设计指导：E-R 图是数据库系统设计的蓝图，为开发人员提供了关于数据库结构和关系的指导，从而帮助他们更好地实现数据库系统。
- 用 E-R 图来描述概念数据模型，世界是由一组称作实体的基本对象和这些对象之间的联系构成的。
- 在 E-R 模型中，使用椭圆表示属性（一般没有）、长方形表示实体、菱形表示联系，联系的两端要填写联系类型。
- E-R 模型转关系模型，每个实体都对应一个关系模式；联系分为三种：
  - 1:1 联系中，联系可以放到任意的两端实体中，作为一个属性（要保证 1:1 的两端关联），也可以转换为一个单独的关系模式。
  - 1:N 的联系中，联系可以单独作为一个关系模式，也可以在 N 端中加入 1 端实体的主键。
  - M:N 的联系中，联系必须作为一个单独的关系模式，其主键是 M 和 N 端的联合主键。

![E-R 图](https://jsd.cdn.zzko.cn/gh/orionpax1997/picx-images-hosting@master/image.67xa3i9gk5.webp "E-R 图")
![E-R 图](https://jsd.cdn.zzko.cn/gh/orionpax1997/picx-images-hosting@master/image.92py9avjcu.webp "E-R 图")

##### 行为模型（状态转换图）

![状态转换图](https://jsd.cdn.zzko.cn/gh/orionpax1997/picx-images-hosting@master/image.969k6zvs4n.webp "状态转换图")

![状态转换图图例](https://jsd.cdn.zzko.cn/gh/orionpax1997/picx-images-hosting@master/image.8ojiierb1g.webp "状态转换图图例")

只能有一个初始状态，可以有多个中间状态和最终状态。中间状态的状态名必须要有，状态变量和行为可选。

#### 面向对象建模（需求分析）

面向对象的分析，是为了**确定问题域，理解问题**。包含五个活动：**认定对象、组织对象、描述对象间的相互作用、确定对象的操作、定义对象的内部信息**。

![面向对象需求建模](https://jsd.cdn.zzko.cn/gh/orionpax1997/picx-images-hosting@master/image.9nzlvqaym5.webp "面向对象需求建模")

面向对象的分析模型主要由**顶层架构图、用例与用例图、领域概念模型**构成；

面向对象的设计模型则包含**以包图表示的软件体系结构图、以交互图表示的用例实现图、完整精确的类图、针对复杂对象的状态图和用以描述流程化处理过程的活动图**等。

![面向对象的分析模型和设计模型](https://jsd.cdn.zzko.cn/gh/orionpax1997/picx-images-hosting@master/image.3rb1opx9su.webp "面向对象的分析模型和设计模型")

UML（统一建模语言）：是一种**可视化的建模语言，而非程序设计语言**，支持从需求分析开始的软件开发的全过程。
从总体上来看，UML 的结构包括**构造块、规则和公共机制**三个部分。

1. 构造块。UML 有三种基本的构造块，分别是事物（thing）、关系 （relationship）和图（diagram）。事物是 UML 的重要组成部分，关系把事物紧密联系在一起，图是多个相互关联的事物的集合。
2. 公共机制。公共机制是指达到特定目标的公共 UML 方法。
3. 规则。规则是构造块如何放在一起的规定。

UML 的关系：

1. 依赖：**一个事物的语义依赖于另一个事物的语义的变化而变化**。
2. 关联：是一种结构关系，描述了一组链，链是对象之间的连接。分为**组合和聚合，都是部分和整体的关系**，其中组合事物之间关系更强。两个类之间的关联，实际上是两个类所扮演角色的关联，因此，两个类之间可以有多个由不同角色标识的关联。
3. 泛化：一般/特殊的关系，**子类和父类**之间的关系
4. 实现：一个类元指定了另一个类元保证执行的契约。

![UML 的关系](https://jsd.cdn.zzko.cn/gh/orionpax1997/picx-images-hosting@master/image.7w6n0u14yp.webp "UML 的关系")

![UML 图](https://jsd.cdn.zzko.cn/gh/orionpax1997/picx-images-hosting@master/image.3d4lxuyl1s.webp "UML 图")

##### **用例图**

静态图，展现了一组**用例、参与者以及它们之间的关系**。用例图中的参与者是人、硬件或其他系统可以扮演的角色；用例是参与者完成的一系列操作，用例之间的关系有**扩展、包含、泛化**。

![用例图](https://jsd.cdn.zzko.cn/gh/orionpax1997/picx-images-hosting@master/image.839uw9z4ua.webp "用例图")

##### **类图**

静态图，为系统的静态设计视图，展现一组**对象、接口、协作和它们之间的关系**。

![类图](https://jsd.cdn.zzko.cn/gh/orionpax1997/picx-images-hosting@master/image.73trj3qpn3.webp "类图")

##### **状态图**

动态图，展现了一个状态机，描述**单个对象在多个用例中的行为**，包括简单状态和组合状态。转换可以通过**事件触发器**触发，事件触发后相应的**监护条件**会进行检查。状态图中转换和状态是两个独立的概念，如下：图中方框代表状态，箭头上的代表触发事件，实心圆点为起点和终点。

![状态图](https://jsd.cdn.zzko.cn/gh/orionpax1997/picx-images-hosting@master/image.9kfzy162c4.webp "状态图")

##### **活动图**

动态图，是一种**特殊的状态图**，展现了在系统内**从一个活动到另一个活动的流程**。活动的分岔和汇合线是一条水平粗线。牢记下图中**并发分岔、并发汇合、监护表达式、分支、流**等名词及含义。每个分岔的分支数代表了可同时运行的线程数。活动图中能够并行执行的是在一个分岔粗线下的分支上的活动。

![活动图](https://jsd.cdn.zzko.cn/gh/orionpax1997/picx-images-hosting@master/image.6wqjnoi1yu.webp "活动图")

##### 对象图

静态图，展现**某一时刻一组对象及它们之间的关系**，为类图的某一快照。在没有类图的前提下，对象图就是静态设计视图。

![对象图](https://jsd.cdn.zzko.cn/gh/orionpax1997/picx-images-hosting@master/image.lvjpsx9jh.webp "对象图")

##### 序列/顺序图

动态图，是场景的图形化表示，描述了**以时间顺序组织的对象之间的交互活动**。有同步消息（进行阻塞调用，调用者中止执行，等待控制权返回，需要等待返回消息，用实心三角箭头表示），异步消息（发出消息后继续执行，不引起调用者阳塞，也不等待返回消息，由空心箭头表示）、返回消息（由从右到左的虚线箭头表示）三种。

![序列图](https://jsd.cdn.zzko.cn/gh/orionpax1997/picx-images-hosting@master/image.1aot9tn8zy.webp "序列图")

##### 通信/协作图

动态图，即协作图，**强调参加交互的对象的组织**。

![通信图](https://jsd.cdn.zzko.cn/gh/orionpax1997/picx-images-hosting@master/image.8ojiil9fjk.webp "通信图")

##### 构件图

静态图，为系统静态实现视图，**展现了一组构件之间的组织和依赖**。

![构件图](https://jsd.cdn.zzko.cn/gh/orionpax1997/picx-images-hosting@master/image.2obcdv2csn.webp "构件图")

##### 部署图

静态图，为系统静态部署视图，部署图**物理模块的节点分布**。它与构件图相关，通常一个结点包含一个或多个构件。其依赖关系类似于包依赖，因此部署组件之间的依赖是单向的类似于包含关系。

![部署图](https://jsd.cdn.zzko.cn/gh/orionpax1997/picx-images-hosting@master/image.1hs159fntw.webp "部署图")

#### SysML

SysML 是一种通用图形建模语言，用于指定，分析，设计和验证可能包括硬件，软件，信息，人员， 程序和设施的复杂系统。特别是，该语言提供了图形表示，其具有用于建模系统需求，行为，结构和参数的语义基础，用于与其他工程分析模型集成。

- SysML 比 UML 更好地表达系统工程语义（符号解释）。它减少了 UML 的软件偏差，并为需求管理和性能分析添加了两种新的图表类型：需求图和参数图。
- SysML 比 UML 更小，更容易学习。由于 SysML 删除了许多以软件为中心和无偿的构造，因此在图表类型（9 对 13）和总结构中测量的整体语言较小。
- SySML 和 UML 间存在交集，即 SysML 语言中的部分图是和 UML 中的相应图是一致的，例如用例图。同时，SysML 也有基于 UML 扩展而来的图，例如活动图。另外，还有一部分图是 SysML 所特有的，这些图与 UML 间没有关系，例如需求图。

##### 需求图

SysML 提供了需求图 （Requirements Diagram）用于对**系统需求，以及需求与需求及其他元素的追湖关系**进行建模，而在 UML 中则没有需求图。

用例可以有效地捕获功能需求，但不适合表达非功能需求。将基于文本的需求合并到 SysML 中可有效适应各种需求。

![需求图](https://jsd.cdn.zzko.cn/gh/orionpax1997/picx-images-hosting@master/image.5fkelypgy8.webp "需求图")

SysML 规定了七个需求关系，使建模者能够将需求彼此关联以及与其他模型元素关联。这些关系包括定义需求层次结构、派生需求、满足需求、验证需求和细化需求的关系。然而，这些关系的语义并不是在形式上定义的，而是可以解释的。因此，有必要定义一些关于如何使用这些关系的启发式、指南和实践，以便有一个一致的模型。

1. 复合关系：复合需求可以包含需求层次结构中的子需求。复合需求可以声明系统应执行 A 和 B，可以将其分解为系统应执行 A 和系统应进行 B 的子需求。
  ![复合关系](https://jsd.cdn.zzko.cn/gh/orionpax1997/picx-images-hosting@master/image.2vek9btwsg.webp)
2. 派生关系：派生的需求通常对应于系统层次结构下一级的需求。一个简单的例子是车辆加速需求，该需求被分析以导出发动机动力等方面的需求。
  ![派生关系](https://jsd.cdn.zzko.cn/gh/orionpax1997/picx-images-hosting@master/image.8dwoph3vwq.webp)
3. 细化关系：细化关系可用于描述如何使用模型元素或元素集进一步细化需求。例如，可以使用用例或活动图来细化基于文本的功能需求。或者，可以使用它来显示基于文本的需求如何细化模型元素。在这种情况下，可以使用一些阐述的文本来细化不太精细的模型元素。
  ![细化关系](https://jsd.cdn.zzko.cn/gh/orionpax1997/picx-images-hosting@master/image.4xucxe16xs.webp)
4. 满足关系：满足关系描述了设计或实现模型如何满足一个或多个需求。然后，系统建模者可以指定旨在满足要求的系统设计元素。
  ![满足关系](https://jsd.cdn.zzko.cn/gh/orionpax1997/picx-images-hosting@master/image.45hhfnk1qw.webp)
5. 验证关系：验证关系定义了测试用例或其他模型元素如何验证需求。在 SysML 中，测试用例或其他元素可以用作表示任何标准检验方法的通用机制，分析，演示或测试。
  ![验证关系](https://jsd.cdn.zzko.cn/gh/orionpax1997/picx-images-hosting@master/image.7p3yz88z5.webp)
6. 复制关系：真正需要跨产品系列和项目重用需求。典型的方案是适用于产品和/或产品系列中重复使用的项目和要求的法定法规或合同要求。SysML 引入了从属需求的概念。
  ![复制关系](https://jsd.cdn.zzko.cn/gh/orionpax1997/picx-images-hosting@master/image.8dwoph8srq.webp)
7. 追溯关系：追溯关系提供了需求和任何其他模型元素之间的通用关系。追溯的语义不包含任何实际约束，因此非常弱。但是，追溯关系对于将需求与源文档相关联或在规范树中的规范之间建立关系可能很有用。
  ![追溯关系](https://jsd.cdn.zzko.cn/gh/orionpax1997/picx-images-hosting@master/image.7zq8ylzs0r.webp)

### 数据库

#### 非关系型数据库和关系型数据库？

非关系型数据库的优势：
- 性能：NOSQL 是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过 SQL 层的解析，所以性能非常高。
- 可扩展性：同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。

关系型数据库的优势：
- 复杂查询：可以用 SQL 语句方便的在一个表以及多个表之间做非常复杂的数据查询。
- 事务支持：使得对于安全性能很高的数据访问要求得以实现。

其他：
- NOSQL 数据库慢慢开始具备 SQL 数据库的一些复杂查询功能，比如 MongoDB。
- 对于事务的支持也可以用一些系统级的原子操作来实现例如乐观锁之类的方法来曲线救国。

![关系数据库与非关系数据库对比](https://jsd.cdn.zzko.cn/gh/orionpax1997/picx-images-hosting@master/image.41xvjcpoo4.webp "关系数据库与非关系数据库对比")

#### 反规范化设计

规范化设计后，数据库设计者希望**牺牲部分规范化来提高性能**。

采用反规范化技术的益处：**降低连接操作的需求、降低外码和索引的数目，还可能减少表的数目，能够提高查询效率**。

可能带来的问题：**数据的重复存储**，浪费了磁盘空间；可能出现**数据的完整性问题**，为了保障数据的一致性，增加了**数据维护的复杂性，会降低修改速度**。

具体方法：
1. 增加冗余列：在**多个表中保留相同的列**，通过增加数据元余减少或避免查询时的连接操作。
2. 增加派生列：在表中**增加可以由本表或其它表中数据计算生成的列**，减少查询时的连接操作并避免计算或使用集合函数。
3. 重新组表：如果许多用户需要查看两个表连接出来的结果数据，则把这**两个表重新组成一个表来减少连接**而提高性能。
4. 水平分割表：根据一列或多列数据的值，**把数据放到多个独立的表中**，主要用于表数据规模很大、表中数据相对独立或数据需要存放到多个介质上时使用。
5. 垂直分割表：对表进行分割，**将主键与部分列放到一个表中，主键与其它列放到另一个表中**，在查询时减少 I/O 次数。

#### 读写分离与主从复制

##### 什么是数据库读写分离？

一主多从，读写分离，主动同步，是一种常见的数据库架构，一般来说：

- 主库，提供数据库写服务
- 从库，提供数据库读服务
- 主从之间，通过某种机制同步数据

##### 读写分离解决什么问题？

大部分互联网业务**读多写少**，数据库的读往往最先成为性能瓶颈，如果希望：

- **线性提升数据库读性能**
- 通过**消除读写锁冲突**提升数据库写性能

其实如果面临的是“读性能瓶颈”问题，增加缓存可能来得更直接，更容易一点。

##### 读写分离的实现

1. 基于程序代码内部实现：在代码中根据 select、insert 进行路由分类，这类方法也是目前生产环境应用最广泛的。 优点是性能较好，因为在程序代码中实现，不需要增加额外的设备为硬件开支；缺点是需要开发人员来实现，运维人员无从下手。 但是并不是所有的应用都适合在程序代码中实现读写分离，像一些大型复杂的 Java 应用，如果在程序代码中实现读写分离对代码改动就较大。
2. 基于中间代理层实现：代理一般位于客户端和服务器之间，代理服务器接到客户端请求后通过判断后转发到后端数据库。好处是源程序不需要做任何改动就可以实现读写分离，坏处是由于多了一层中间件做中转代理，性能上会有所下降，数据访问代理也容易成为性能瓶颈。

##### mysql 主从复制

1. 当 Master 节点进行 insert、update、delete 操作时，会按顺序写入到 binlog 中。
1. salve 从库连接 master 主库，Master 有多少个 slave 就会创建多少个 binlog dump 线程。
3. 当 Master 节点的 binlog 发生变化时，binlog dump 线程会通知所有的 salve 节点，并将相应的 binlog 内容推送给 slave 节点。
4. I/O 线程接收到 binlog 内容后，将内容写入到本地的 relay-log。
5. SQL 线程读取 I/O 线程写入的 relay-log，并且根据 relay-log 的内容对从数据库做对应的操作。

![Mysql 主从复制](https://jsd.cdn.zzko.cn/gh/orionpax1997/picx-images-hosting@master/image.26laqsbezi.webp "Mysql 主从复制")

#### redis 的数据类型

##### String

这个其实没啥好说的，最常规的 set/get 操作，value 可以是 String 也可以是数字。一般做一些复杂的计数功能的缓存。

##### Hash

这里 value 存放的是结构化的对象，比较方便的就是操作其中的某个字段。博主在做单点登录的时候，就是用这种数据结构存储用户信息，以 cookieId 作为 key，设置 30 分钟为缓存过期时间，能很好的模拟出类似 session 的效果。

##### List

使用 List 的数据结构，可以做简单的消息队列的功能。另外还有一个就是，可以利用 lrange 命令，做基于 redis 的分页功能，性能极佳，用户体验好。本人还用一个场景，很合适—取行情信息。就也是个生产者和消费者的场景。LIST 可以很好的完成排队，先进先出的原则。

##### Set

因为 set 堆放的是一堆不重复值的集合。所以可以做全局去重的功能。为什么不用 JVM 自带的 Set 进行去重？因为我们的系统一般都是集群部署，使用 JVM 自带的 Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。

另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。

##### sorted set(Zset)

sorted set 多了一个权重参数 score,集合中的元素能够按 score 进行排列。可以做排行榜应用，取 TOP N 操作。

#### 缓存雪崩

缓存雪崩我们可以简单的理解为：由于原有缓存失效，新缓存未到期间（例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期），所有原本应该访问缓存的请求都去查询数据库了，而对数据库 CPU 和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。

解决办法：

- 大多数系统设计者考虑用加锁（ 最多的解决方案）或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。
- 还有一个简单方案就时讲缓存失效时间分散开。
- 当然也可以考虑，Redis 的高可用模式，哨兵或者是主从。

#### 布隆过滤器与缓存穿透

##### 布隆过滤器

布隆过滤器是一种概率型数据结构，它的特点是**高效的插入和查询**，能确定某个字符串**一定不存在或者可能存在**。

布隆过滤器**不存储具体数据，所以占用空间小，查询结果存在误差，但误差可控，同时不支持删除操作**。

布隆过滤器的原理本质上和散列表是一样的。但布隆过滤器为了节约内存，不是使用的数组，而是使用的位图。

当一个元素加入位图时，通过 k 个 hash 函数将元素映射到位图的 k 个点，并把它们置 1；当检索时，再通过 k 个 hash 函数运算检查位图的 k 个点是否都为 1；如果有不为 1 的点，那么认为该 key 不存在；如果全部为 1，则可能存在（跟 hash 函数的个数和 hash 函数的设计有关）。

##### 缓存穿透

我们经常会把一部分数据放在 Redis 等缓存，比如产品详情。这样有查询请求进来，我们可以根据产品 Id 直接去缓存中取数据，而不用读取数据库，这是提升性能最简单，最普遍，也是最有效的做法。一般的查询请求流程是这样的：先查缓存，有缓存的话直接返回，如果缓存中没有，再去数据库查询，然后再把数据库取出来的数据放入缓存，一切看起来很美好。但是如果现在有大量请求进来，而且都在请求一个不存在的产品 Id，会发生什么？既然产品 Id 都不存在，那么肯定没有缓存，没有缓存，那么大量的请求都怼到数据库，数据库的压力一下子就上来了，还有可能把数据库打死。这也是黑客利用漏洞攻击的一种方式，**大量重复请求不存在的数据**。

解决方案：
1. 在 redis 设置<key，null>键值对，依次避免访问数据库；缺点是<key，null>过多会占用过多内存，可以给 key 设置过期 expire key 600ms，停止攻击后最终由 redis 自动清除无用的 key。
2. 在服务端存储一个布隆过滤器，将存在的 key 放入布隆过滤器中，布隆过滤器可以过滤一定不存在的数据，能够穿透缓存的漏网之鱼，无关紧要。

#### 缓存击穿

缓存击穿，就是说某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况，当这个 **key 在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库**，就像是在一道屏障上凿开了一个洞。

不同场景下的解决方式可如下：
- 若缓存的数据是基本不会发生更新的，则可尝试将该热点数据设置为永不过期。
- 若缓存的数据更新不频繁，且缓存刷新的整个流程耗时较少的情况下，则可以采用基于 redis、zookeeper 等分布式中间件的分布式互斥锁，或者本地互斥锁以保证仅少量的请求能请求数据库并重新构建缓存，其余线程则在锁释放后能访问到新缓存。
- 若缓存的数据更新频繁或者缓存刷新的流程耗时较长的情况下，可以利用定时线程在缓存过期前主动的重新构建缓存或者延后缓存的过期时间，以保证所有的请求能一直访问到对应的缓存。

#### 缓存分片（负载均衡）

##### 为什么分片？

1. 解决数据容量限制：单个 Redis 实例的数据存储是有限的，当**数据量超过单个实例的存储能力时，就需要进行分片**。分片可以将数据均匀地分布在多个实例中，从而解决了数据容量限制的问题。
2. 提高读写性能：分片可以将负载分散到多个 Redis 实例上，同时充分利用多核处理器的性能，提高读写性能。当多个实例并行处理请求时，整体的处理能力将大大增强。
3. 实现高可用性：通过复制和故障转移机制，使得分片的 Redis 集群可以提供高可用性。当一个节点发生故障时，系统可以自动将请求路由到其他可用的节点，从而实现故障恢复和高可用性。
4. 支持横向扩展：通过增加新的 Redis 实例，可以方便地实现系统的横向扩展。当业务需求增加时，可以简单地增加更多的节点，而不需要修改现有的代码和架构。

##### 范围分片

分片需要将不同 key 映射到不同 Redis 实例上存储，所以 key 的映射规则需要制定一个算法，最简单的一个分片方案应该是范围分片。

范围分片理解起来很简单，比如我们存储用户基本信息，我们制定一个算法将用户 user_id 从 0 到 1000 映射到实例 A，user_id 从 1000 到 2000 映射到实例 B，以此类推。这个方案很轻松可以使用。

但是引发了一个问题：我们需要维护 user_id 范围和映射实例之间的关系。而正是这个问题导致范围分片虽然简单，但是效率比其他分片方案低效许多，所以 Redis 中一般不会使用范围分片作为分片方案。

##### 哈希分片

比如我们目前有四个 Redis 实例，我们需要存储一个 key。我们可以通过哈希函数 crc32 将 key 名转换成一个长整型数字，然后对长整型数字对 4 取余，就可以得到映射的实例。

但是这种分配方案一样存在弊端：当我们需要增加或移除 Redis 实例时，就会造成大量 key 无法被命中。

##### 一致性哈希分片

用一致性 Hash 算法可以很好地解决增加和删减节点时，命中率下降的问题。在这个算法中，我们将整个 Hash 值空间组织成一个虚拟的圆环，然后将缓存节点的 IP 地址或者主机名做 Hash 取值后，放置在这个圆环上。当我们需要确定某一个 Key 需要存取到哪个节点上的时候，先对这个 Key 做同样的 Hash 取值，确定在环上的位置，然后按照顺时针方向在环上“行走”，遇到的第一个缓存节点就是要访问的节点。

比方说下面这张图里面，Key 1 和 Key 2 会落入到 Node 1 中，Key 3、Key 4 会落入到 Node 2 中，Key 5 落入到 Node 3 中，Key 6 落入到 Node 4 中。

![一致性哈希分片](https://jsd.cdn.zzko.cn/gh/orionpax1997/picx-images-hosting@master/image.8s34j74u78.webp "一致性哈希分片")

##### Redis Cluster 哈希槽

Redis Cluster 并没有使用一致性 hash，而是引入了哈希槽的概念。

Redis 集群有 16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽。集群的每个节点负责一部分 hash 槽，举个例子，比如当前集群有 3 个节点，那么节点 A 包含 0 到 5500 号哈希槽，节点 B 包含 5501 到 11000 号哈希槽，节点 C 包含 11001 到 16384 号哈希槽。

##### 为什么 Redis Cluster 使用哈希槽而不是一致性哈希？

1. 一致性哈希的节点分布基于圆环，无法很好的手动设置数据分布，比如有些节点的硬件差，希望少存一点数据，这种很难操作。而哈希槽可以很灵活的配置每个节点占用哈希槽的数量。
2. 一致性哈希的某个节点宕机或者掉线后，当该机器上原本缓存的数据被请求时，会从数据源重新获取数据，并将数据添加到失效机器后面的机器，这个过程被称为 "缓存抖动" ，而使用哈希槽的节点宕机，会导致一定范围内的槽不可用，只能通过主从复制加哨兵模式保证高可用。
3. 基于一致性哈希的特点，当某台机器宕机时，极易引起雪崩，删除节点就会把当前节点所有数据加到它的下一个节点上。这样会导致下一个节点使用率暴增，可能会导致挂掉，如果下一个节点挂掉，下下个节点将会承受更大的压力，最终导致集群雪崩。
4. Redis Cluster 的槽位空间是可以用户手动自定义分配的，类似于 windows 盘分区的概念，可以手动控制大小。
5. 相对于哈希槽，一致性哈希算法更复杂。

#### Redis 持久化

Redis 的持久化策略有两种：

- RDB：快照形式是直接把内存中的数据保存到一个 dump 的文件中，定时保存，保存策略。
  - RDB 的优点是：这种文件非常适合用于备份：比如，你可以在最近的 24 小时内，每小时备份一次，并且在每个月的每一天也备份一个 RDB 文件。
  - RDB 的缺点是：如果你需要尽量避免在服务器故障时丢失数据，那么 RDB 不合适你。
- AOF：把所有的对 Redis 的服务器进行修改的命令都存到一个文件里，命令的集合。Redis 默认是快照 RDB 的持久化方式。
  - AOF 的默认策略是每秒钟 Fsync 一次，在这种配置下，就算发生故障停机，也最多丢失一秒钟的数据。
  - 缺点是对于相同的数据集来说，AOF 的文件体积通常要大于 RDB 文件的体积。根据所使用的 Fsync 策略，AOF 的速度可能会慢于 RDB。将 Redis 执行的每一条命令追加到磁盘中，处理巨大的写入会降低 Redis 的性能。

支持同时开启 RDB 和 AOF，系统重启后，Redis 会优先使用 AOF 来恢复数据，这样丢失的数据会最少。

#### Redis 主从模式与哨兵模式

##### 主从模式

主从复制，是指将一台 Redis 服务器的数据，复制到其他的 Redis 服务器。

前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。

![主从模式](https://jsd.cdn.zzko.cn/gh/orionpax1997/picx-images-hosting@master/image.9dcs5ljbfk.webp "主从模式")

主从模式的优点：

- 一旦 主节点宕机，从节点 作为 主节点 的 备份 可以随时顶上来。
- 扩展 主节点 的 读能力，分担主节点读压力。
- 高可用基石：除了上述作用以外，主从复制还是哨兵模式和集群模式能够实施的基础，因此说主从复制是 Redis 高可用的基石。

也有相应的缺点：

- 一旦 主节点宕机，从节点 晋升成 主节点，同时需要修改 应用方 的 主节点地址，还需要命令所有 从节点 去 复制 新的主节点，整个过程需要 人工干预。
- 主节点 的 写能力 受到 单机的限制。
- 主节点 的 存储能力 受到 单机的限制。
- 有数据冗余问题。

##### 哨兵模式

在复制的基础上，哨兵实现了自动化的故障恢复。

![哨兵模式](https://jsd.cdn.zzko.cn/gh/orionpax1997/picx-images-hosting@master/image.86tgx01b40.webp "哨兵模式") 

1. 每个Sentinel以 每秒钟 一次的频率，向它所有的 主服务器、从服务器 以及其他Sentinel实例 发送一个PING 命令。
2. 如果一个 实例（instance）距离最后一次有效回复 PING命令的时间超过 down-after-milliseconds 所指定的值，那么这个实例会被 Sentinel标记为 主观下线。
3. 如果一个 主服务器 被标记为 主观下线，那么正在 监视 这个 主服务器 的所有 Sentinel 节点，要以 每秒一次 的频率确认 该主服务器是否的确进入了 主观下线 状态。
4. 如果一个 主服务器 被标记为 主观下线，并且有 足够数量 的 Sentinel（至少要达到配置文件指定的数量）在指定的 时间范围 内同意这一判断，那么这个该主服务器被标记为 客观下线。
5. 在一般情况下， 每个 Sentinel 会以每 10秒一次的频率，向它已知的所有 主服务器 和 从服务器 发送 INFO 命令。
6. 当一个 主服务器 被 Sentinel标记为 客观下线 时，Sentinel 向 下线主服务器 的所有 从服务器 发送 INFO 命令的频率，会从10秒一次改为 每秒一次。
7. Sentinel和其他 Sentinel 协商 主节点 的状态，如果 主节点处于 SDOWN`状态，则投票自动选出新的主节点。将剩余的 从节点 指向 新的主节点 进行 数据复制。
8. 当没有足够数量的 Sentinel 同意 主服务器 下线时， 主服务器 的 客观下线状态 就会被移除。当 主服务器 重新向 Sentinel的PING命令返回 有效回复 时，主服务器 的 主观下线状态 就会被移除。

![哨兵模式原理](https://jsd.cdn.zzko.cn/gh/orionpax1997/picx-images-hosting@master/image.syro8k4vr.webp "哨兵模式原理") 

优点：

- 哨兵模式是基于主从模式的，所有主从的优点，哨兵模式都具有。
- 主从可以自动切换，系统更健壮，可用性更高。
- Sentinel 会不断的检查 主服务器 和 从服务器 是否正常运行。当被监控的某个 Redis 服务器出现问题，Sentinel 通过API脚本向管理员或者其他的应用程序发送通知。

缺点：Redis较难支持在线扩容，对于集群，容量达到上限时在线扩容会变得很复杂。

#### 怎么保证分布式缓存与数据库的双写一致性？

##### 一致性的级别

一致性就是数据保持一致，在分布式系统中，可以理解为多个节点中数据的值是一致的。

- 强一致性：这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也会是什么，用户体验好，但实现起来往往对系统的性能影响大
- 弱一致性：这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态
- 最终一致性：最终一致性是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态。这里之所以将最终一致性单独提出来，是因为它是弱一致性中非常推崇的一种一致性模型，也是业界在大型分布式系统的数据一致性上比较推崇的模型

##### 三个经典的缓存模式

###### Cache-Aside Pattern（旁路缓存）

最经典的缓存+数据库读写的模式，就是 Cache Aside Pattern。它的提出是为了尽可能地解决缓存与数据库的数据不一致问题。

读的时候，**先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存**，同时返回响应。

![Cache-Aside 读流程](https://jsd.cdn.zzko.cn/gh/orionpax1997/picx-images-hosting@master/image.5xagdg3s8c.webp "Cache-Aside 读流程")

更新的时候，**先更新数据库，然后再删除缓存**。

![Cache-Aside 写流程](https://jsd.cdn.zzko.cn/gh/orionpax1997/picx-images-hosting@master/image.7p3f8cofi7.webp "Cache-Aside 写流程")

###### Read/Write Through（读写穿透）

Read/Write Through 模式中，服务端把缓存作为主要数据存储。应用程序跟数据库缓存交互，都是通过抽象缓存层完成的。

从缓存读取数据，读到直接返回，如果读取不到的话，从数据库加载，写入缓存后，再返回响应。看上去和 Cache-Aside 一样，其实 Read-Through 就是多了一层 Cache-Provider。

![Read Through 流程](https://jsd.cdn.zzko.cn/gh/orionpax1997/picx-images-hosting@master/image.8ad2unq6oh.webp "Read Through 流程")

写流程也是由缓存抽象层完成数据源和缓存数据的更新。

![Write Through 流程](https://jsd.cdn.zzko.cn/gh/orionpax1997/picx-images-hosting@master/image.pf5qglj0q.webp "Write Through 流程")

###### Write behind（异步缓存写入）

Write behind 跟 Read-Through/Write-Through 有相似的地方，都是由 Cache Provider 来负责缓存和数据库的读写。

区别是，Read/Write Through 是同步更新缓存和数据的，Write Behind 则是只更新缓存，不直接更新数据库，通过批量异步的方式来更新数据库。

![Write behind 流程](https://jsd.cdn.zzko.cn/gh/orionpax1997/picx-images-hosting@master/image.lw6g0nww.webp "Write behind 流程")

这种方式下，缓存和数据库的一致性不强，对一致性要求高的系统要谨慎使用。但是它适合频繁写的场景，MySQL 的 InnoDB Buffer Pool 机制就使用到这种模式。

##### 为什么是删除缓存，而不是更新缓存？

原因很简单，很多时候，在复杂点的缓存场景，缓存不单单是数据库中直接取出来的值。

比如可能更新了某个表的一个字段，然后其对应的缓存，是需要查询另外两个表的数据并进行运算，才能计算出缓存最新的值的。

另外**更新缓存的代价有时候是很高的**。是不是说，每次修改数据库的时候，都一定要将其对应的缓存更新一份？也许有的场景是这样，但是对于比较复杂的缓存数据计算的场景，就不是这样了。如果你频繁修改一个缓存涉及的多个表，缓存也频繁更新。但是问题在于，这个缓存到底会不会被频繁访问到？

举个栗子，一个缓存涉及的表的字段，在 1 分钟内就修改了 20 次，或者是 100 次，那么缓存更新 20 次、100 次；但是这个缓存在 1 分钟内只被读取了 1 次，有大量的冷数据。实际上，如果你只是删除缓存的话，那么在 1 分钟内，这个缓存不过就重新计算一次而已，开销大幅度降低，用到缓存才去算缓存。

其实删除缓存，而不是更新缓存，就是一个 lazy 计算的思想，不要每次都重新做复杂的计算，不管它会不会用到，而是让它到需要被使用的时候再重新计算。像 mybatis，hibernate，都有懒加载思想。查询一个部门，部门带了一个员工的 list，没有必要说每次查询部门，都里面的 1000 个员工的数据也同时查出来啊。80% 的情况，查这个部门，就只是要访问这个部门的信息就可以了。先查部门，同时要访问里面的员工，那么这个时候只有在你要访问里面的员工的时候，才会去数据库里面查询 1000 个员工。

##### 双写的情况下，先操作数据库还是先操作缓存？

在写入请求的时候，为什么是先操作数据库呢？为什么不先操作缓存呢？

假设有 A、B 两个请求，请求 A 做更新操作，请求 B 做查询读取操作。

![并发读写流程](https://jsd.cdn.zzko.cn/gh/orionpax1997/picx-images-hosting@master/image.45i4659i5.webp "并发读写流程")

1. 线程 A 发起一个写操作，第一步 del cache
2. 此时线程 B 发起一个读操作，cache miss
3. 线程 B 继续读 DB，读出来一个老数据
4. 然后线程 B 把老数据设置入 cache
5. 线程 A 写入 DB 最新的数据

这样就有问题啦，缓存和数据库的数据不一致了。缓存保存的是老数据，数据库保存的是新数据。因此，Cache-Aside 缓存模式，选择了先操作数据库而不是先操作缓存。

##### 缓存延时双删

1. 先删除缓存
2. 再更新数据库
3. 休眠一会（休眠时间 = 读业务逻辑数据的耗时 + 几百毫秒，为了确保读请求结束，写请求可以删除读请求可能带来的缓存脏数据），再次删除缓存。

![延时双删](https://jsd.cdn.zzko.cn/gh/orionpax1997/picx-images-hosting@master/image.39l0348kqp.webp "延时双删")

##### 删除缓存重试机制

不管是延时双删还是 Cache-Aside 的先操作数据库再删除缓存，如果第二步的删除缓存失败呢，删除失败会导致脏数据。所以可以引入删除缓存重试机制。

1. 写请求更新数据库
2. 缓存因为某些原因，删除失败
3. 把删除失败的 key 放到消息队列
4. 消费消息队列的消息，获取要删除的 key
5. 重试删除缓存操作

![删除缓存重试机制](https://jsd.cdn.zzko.cn/gh/orionpax1997/picx-images-hosting@master/image.92pycezoj5.webp "删除缓存重试机制")

##### 读取 binlog 异步删除缓存

重试删除缓存机制还可以，就是会造成好多业务代码入侵。其实，还可以通过数据库的 binlog 来异步淘汰 key。

以 mysql 为例 可以使用阿里的 canal 将 binlog 日志采集发送到 MQ 队列里面，然后通过 ACK 机制确认处理这条更新消息，删除缓存，保证数据缓存一致性。

![通过 binlog 异步删除缓存](https://jsd.cdn.zzko.cn/gh/orionpax1997/picx-images-hosting@master/image.8hgaq48gob.webp "通过 binlog 异步删除缓存")

## 论文

### 整体结构

- 摘要
- 项目背景
- 项目启动时间、岗位、职责、投入、建设周期、项目主要建设内容、技术架构
- **按题目，回应问题，分层结构**
- 开发时间、投入使用后的作用、反馈良好、系统建设困难克服困难、不懈努力后顺利交付

### 分层思路

- 层次式架构
  - 用户界面表示层
    - Vue：组件化、轻量级、双向数据绑定、学习成本低
    - Vuex：状态集中管理、组件间共享
    - Element UI：美观度、主题适合
  - 负载均衡控制层
    - RESTful：简单、松耦合、自文档
    - Spring Web
    - Ngnix：高性能、配置灵活
    - Spring Security
  - 业务逻辑处理层
    - 规则引擎
    - MVEL：可编译、性能
    - Microsoft Language Server Protocol：语法分析、自动完成、调试
    - Monaco Editor
    - 版本控制
  - 数据访问层
    - Redis：高可用、简单
    - DBMS：举例子
- 大数据架构 Kappa
  - 数据采集层
    - Kafka：高吞吐量处理大数据流、持久性、容错、社区支持
    - 数据标准化
    - 历史数据重放
  - 数据处理层
    - Flink：实时处理、事件处理、状态管理、精确一次处理确保数据处理不重复
    - 规则引擎
    - MVEL：可编译、性能
    - Microsoft Language Server Protocol：语法分析、自动完成、调试
    - Monaco Editor
    - 版本控制
    - 举例子
  - 数据存储层
    - Hadoop：分布式海量数据存储、高容错、可伸缩、安全、数据压缩、通过计算和分布式实现容错成本较低
    - Redis：高可用、简单
  - 数据展现层和安全监控层
    - Vue：组件化、轻量级、双向数据绑定、学习成本低
    - Vuex：状态集中管理、组件间共享
    - Element UI：美观度、主题适合
    - Zabbix：全面实时监控、报警、灵活、自动发现
- 面向服务的架构 SOA
  - 服务注册中心
    - ESB：集成了不同协议的不同服务，做了消息的转化、解释以及路由的工作，让不同的服务联通
  - 服务请求者
    - 客户端
  - 服务提供者
    - 各种类型不同实现方式的规则
    - 规则引擎
    - 数据同步
- 论系统建模方法及其应用
  - 结构化的特点：**自顶向下、逐步分解、面向数据**
  - 三大模型及数据字典：**功能模型（数据流图）、行为模型（状态转换图）、数据模型（E-R 图）**
  - 功能模型
    - 质控流程数据流向
  - 行为模型
    - 违规状态变换
  - 数据模型
    - 哪些实体和它们的联系
- 论软件系统架构风格
  - 5 大风格介绍
  - 规则系统
  - 仓库-数据库
  - 批处理
  - 层次化和面向对象
- 论软件架构的评估
  - 场景和需求收集
  - 体系结构视图和场景实现
  - 属性模型构造和分析
  - 折中
